{% extends "base.html" %}
{% load static %}

{% block title %}Super Breakout - GFN Retro Hub{% endblock %}

{% block content %}
<main class="main-content">
    <h2>Super Breakout</h2>

    <div id="difficultySelector">
        <h3>Wähle eine Schwierigkeit:</h3>
        <button class="difficulty-btn" data-difficulty="easy">Leicht</button>
        <button class="difficulty-btn" data-difficulty="medium">Mittel</button>
        <button class="difficulty-btn" data-difficulty="hard">Schwer</button>
    </div>

    <div id="gameContainer" style="display: none;">
        <div class="game-info" style="display: flex; justify-content: space-around; max-width: 800px; margin: 10px auto; font-size: 1.2em;">
            <span id="score">Score: 0</span>
            <span id="lives">Lives: 3</span>
        </div>
        <canvas id="gameCanvas" width="800" height="600" style="background-color: #050515; border: 3px solid #00ffff; box-shadow: 0 0 10px #00ffff;"></canvas>
    </div>

    <div id="gameOverModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center; flex-direction: column;">
        <h2 id="finalScore" style="font-size: 2em; color: #ffff00;"></h2>
        <p>Trage dich in die Halle der Legenden ein!</p>
        <form id="highscoreForm">
            <input type="text" id="playerName" placeholder="Dein Name" required style="background-color: #333; border: 1px solid #fff; color: #fff; padding: 10px; font-family: 'Press Start 2P', cursive; font-size: 1em; text-align: center;">
            <button type="submit" style="background-color: #00ffff; color: #000; border: none; padding: 12px 20px; font-family: 'Press Start 2P', cursive; cursor: pointer; font-size: 1em;">SPEICHERN</button>
        </form>
         <button onclick="document.location.reload()" style="margin-top: 20px; background-color: #ff00ff; color: #fff; border:none; padding: 10px 15px; font-family: 'Press Start 2P', cursive; cursor: pointer;">NEUSTART</button>
    </div>
</main>
{% endblock %}

{% block extra_js %}
<style>
    /* Styling für die neuen Buttons */
    .difficulty-btn {
        background-color: #00ffff;
        color: #000;
        border: none;
        padding: 15px 25px;
        margin: 10px;
        font-family: 'Press Start 2P', cursive;
        cursor: pointer;
        font-size: 1em;
        transition: all 0.2s ease-in-out;
    }
    .difficulty-btn:hover {
        background-color: #ffff00;
        box-shadow: 0 0 15px #ffff00;
    }
</style>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI-Elemente
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const highscoreForm = document.getElementById('highscoreForm');
    const playerNameInput = document.getElementById('playerName');
    const difficultySelector = document.getElementById('difficultySelector');
    const gameContainer = document.getElementById('gameContainer');
    const difficultyButtons = document.querySelectorAll('.difficulty-btn');

    // Spiel-Variablen
    let score = 0;
    let lives = 3;
    let bricks = [];
    let particles = [];
    let gameRunning = false; // Spiel startet erst nach Auswahl

    // Paddel
    const paddle = {
        x: canvas.width / 2 - 50,
        y: canvas.height - 20,
        width: 120, // Standard-Breite
        height: 15,
        dx: 0,
        color: '#00ffff'
    };

    // Ball
    const ball = {
        x: canvas.width / 2,
        y: canvas.height - 40,
        radius: 10,
        speed: 5, // Standard-Geschwindigkeit
        dx: 4,
        dy: -4,
        color: '#ffff00'
    };

    // Blöcke (unverändert)
    const brickInfo = {
        rowCount: 5,
        columnCount: 9,
        width: 75,
        height: 20,
        padding: 10,
        offsetTop: 50,
        offsetLeft: 30,
        colors: ['#ff00ff', '#ff00ff', '#00ffff', '#00ffff', '#ffff00']
    };

    // NEU: Einstellungen für Schwierigkeitsstufen
    const difficultySettings = {
        easy: { ballSpeed: 4, paddleWidth: 150 },
        medium: { ballSpeed: 5, paddleWidth: 120 },
        hard: { ballSpeed: 7, paddleWidth: 90 }
    };

    // Event-Listener für die Schwierigkeits-Buttons
    difficultyButtons.forEach(button => {
        button.addEventListener('click', () => {
            const difficulty = button.dataset.difficulty;
            startGame(difficulty);
        });
    });

    // NEU: Funktion zum Starten des Spiels
    function startGame(difficulty) {
        // Einstellungen anwenden
        const settings = difficultySettings[difficulty];
        ball.speed = settings.ballSpeed;
        paddle.width = settings.paddleWidth;

        // UI anpassen
        difficultySelector.style.display = 'none';
        gameContainer.style.display = 'block';

        // Spiel starten
        gameRunning = true;
        resetBallAndPaddle();
        createBricks();
        update();
    }
    
    // Partikel-Klasse für Effekte (unverändert)
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.radius = Math.random() * 2 + 1;
            this.dx = (Math.random() - 0.5) * 4;
            this.dy = (Math.random() - 0.5) * 4;
            this.life = 50;
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();
        }
        update() { this.x += this.dx; this.y += this.dy; this.life--; this.draw(); }
    }

    function createBricks() {
        bricks = [];
        for (let c = 0; c < brickInfo.columnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickInfo.rowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1, color: brickInfo.colors[r] };
            }
        }
    }

    // Alle Zeichen-Funktionen (drawBall, drawPaddle, etc.) bleiben unverändert
    function drawBall() {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color; ctx.shadowColor = ball.color;
        ctx.shadowBlur = 15; ctx.fill(); ctx.closePath(); ctx.shadowBlur = 0;
    }
    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.fillStyle = paddle.color; ctx.shadowColor = paddle.color;
        ctx.shadowBlur = 10; ctx.fill(); ctx.closePath(); ctx.shadowBlur = 0;
    }
    function drawBricks() {
        for (let c = 0; c < brickInfo.columnCount; c++) {
            for (let r = 0; r < brickInfo.rowCount; r++) {
                if (bricks[c][r].status === 1) {
                    const brickX = c * (brickInfo.width + brickInfo.padding) + brickInfo.offsetLeft;
                    const brickY = r * (brickInfo.height + brickInfo.padding) + brickInfo.offsetTop;
                    bricks[c][r].x = brickX; bricks[c][r].y = brickY;
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickInfo.width, brickInfo.height);
                    ctx.fillStyle = bricks[c][r].color;
                    ctx.fill(); ctx.closePath();
                }
            }
        }
    }
    function drawParticles() {
        particles.forEach((p, index) => {
            if (p.life <= 0) { particles.splice(index, 1); } else { p.update(); }
        });
    }

    // Alle Bewegungs- und Kollisions-Funktionen bleiben unverändert
    function moveBall() {
        ball.x += ball.dx; ball.y += ball.dy;
        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) { ball.dx *= -1; }
        if (ball.y - ball.radius < 0) { ball.dy *= -1; }
        if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
            let collidePoint = ball.x - (paddle.x + paddle.width / 2);
            collidePoint = collidePoint / (paddle.width / 2);
            let angle = collidePoint * (Math.PI / 3);
            ball.dx = ball.speed * Math.sin(angle);
            ball.dy = -ball.speed * Math.cos(angle);
        }
        if (ball.y + ball.radius > canvas.height) {
            lives--;
            livesEl.textContent = `Lives: ${lives}`;
            if (lives <= 0) { gameOver(); } else { resetBallAndPaddle(); }
        }
    }
    function collisionDetection() {
        for (let c = 0; c < brickInfo.columnCount; c++) {
            for (let r = 0; r < brickInfo.rowCount; r++) {
                const b = bricks[c][r];
                if (b.status === 1) {
                    if (ball.x > b.x && ball.x < b.x + brickInfo.width && ball.y > b.y && ball.y < b.y + brickInfo.height) {
                        ball.dy *= -1; b.status = 0;
                        score += 10;
                        scoreEl.textContent = `Score: ${score}`;
                        for (let i = 0; i < 15; i++) {
                            particles.push(new Particle(ball.x, ball.y, b.color));
                        }
                        if (score === brickInfo.rowCount * brickInfo.columnCount * 10) {
                            alert('YOU WIN!');
                            gameOver();
                        }
                    }
                }
            }
        }
    }
    
    // Maussteuerung (unverändert)
    canvas.addEventListener('mousemove', (e) => {
        const relativeX = e.clientX - canvas.getBoundingClientRect().left;
        if (relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
        }
    });

    // Haupt-Game-Loop (unverändert)
    function update() {
        if (!gameRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks(); drawPaddle(); drawBall(); drawParticles();
        moveBall(); collisionDetection();
        requestAnimationFrame(update);
    }

    // Reset-, GameOver- und Highscore-Funktionen (unverändert)
    function resetBallAndPaddle() {
        ball.x = canvas.width / 2;
        ball.y = paddle.y - 20; // Startet näher am Paddel
        // Startwinkel zufällig machen
        let angle = (Math.random() * (Math.PI / 2)) - (Math.PI / 4); // -45 bis +45 Grad
        ball.dx = ball.speed * Math.sin(angle);
        ball.dy = -ball.speed * Math.cos(angle);
        paddle.x = canvas.width / 2 - paddle.width / 2;
    }

    function gameOver() {
        gameRunning = false;
        finalScoreEl.textContent = `Game Over! Score: ${score}`;
        gameOverModal.style.display = 'flex';
    }

    highscoreForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const playerName = playerNameInput.value;
        fetch("{% url 'games:save_score' %}", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({ player_name: playerName, game: 'Super Breakout', score: score })
        }).then(response => {
            window.location.href = "{% url 'games:highscores' %}";
        }).catch(error => console.error('Error:', error));
    });
    
    // Das Spiel startet nicht mehr automatisch, sondern wartet auf einen Button-Klick.
});
</script>
{% endblock %}