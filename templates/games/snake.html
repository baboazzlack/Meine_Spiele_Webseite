{% extends 'base.html' %}
{% load static %}

{% block title %}Snake - GFN Retro Hub{% endblock %}

{% block content %}
<main class="game-container-main">
    <div class="game-header">
        <h1 class="game-title-h1">Snake</h1>
        <p class="game-description">Der unsterbliche Klassiker. Werde länger, aber beiß dir nicht in den eigenen Schwanz.</p>
    </div>

    <div class="game-controls">
        <label for="difficulty">Schwierigkeit:</label>
        <select id="difficulty">
            <option value="easy">Leicht</option>
            <option value="medium" selected>Mittel</option>
            <option value="hard">Schwer</option>
        </select>
        <button id="startGameBtn">Spiel starten</button>
    </div>

    <div class="game-info">
        <p>Punkte: <span id="score">0</span></p>
    </div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div id="gameOverModal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>Game Over</h2>
            <p>Dein Score: <span id="finalScore">0</span></p>
            <p>Trage dich in die Highscore-Liste ein:</p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="15">
            <div class="modal-actions">
                <button id="saveScoreBtn">Speichern</button>
                <button id="restartGameBtn">Neues Spiel</button>
                <button id="closeModalBtn">Schließen</button>
            </div>
        </div>
    </div>
</main>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elemente ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const difficultySelect = document.getElementById('difficulty');
    const startBtn = document.getElementById('startGameBtn');
    const modal = document.getElementById('gameOverModal');
    const finalScoreElement = document.getElementById('finalScore');
    const playerNameInput = document.getElementById('playerNameInput');
    const saveScoreBtn = document.getElementById('saveScoreBtn');
    // NEUE BUTTONS
    const restartGameBtn = document.getElementById('restartGameBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');


    // --- Spiel-Konstanten & Design ---
    const GRID_SIZE = 20;
    const CANVAS_WIDTH = canvas.width;
    const CANVAS_HEIGHT = canvas.height;
    const TILE_COUNT = CANVAS_WIDTH / GRID_SIZE;

    const COLORS = {
        BACKGROUND: '#000',
        GRID: 'rgba(0, 255, 255, 0.1)',
        SNAKE_HEAD: '#39ff14',
        SNAKE_BODY: '#28a700',
        SNAKE_GLOW: '#39ff14',
        SNAKE_EYE: '#000',
        FOOD: '#ff00ff',
        FOOD_GLOW: '#ff00ff'
    };

    const difficultySettings = {
        easy: 150,
        medium: 100,
        hard: 60
    };

    // --- Spiel-Variablen ---
    let snake, food, score, direction, changingDirection, gameLoopId, isGameOver;

    function init() {
        snake = [{ x: 10, y: 10 }];
        food = {};
        score = 0;
        direction = { x: 0, y: 0 };
        changingDirection = false;
        isGameOver = false;
        scoreElement.textContent = '0';
        modal.style.display = 'none';
        draw(); // Zeichnet den initialen leeren Zustand
        generateFood();
    }

    function startGame() {
        if (gameLoopId) clearInterval(gameLoopId);
        init();
        const speed = difficultySettings[difficultySelect.value];
        startBtn.disabled = true;
        difficultySelect.disabled = true;
        // Startverzögerung, damit der Spieler die Richtung wählen kann
        direction = { x: 1, y: 0 }; 
        gameLoopId = setInterval(mainLoop, speed);
    }

    function mainLoop() {
        if (isGameOver) return;
        changingDirection = false;
        update();
        draw();
    }

    function update() {
        const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

        if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
            return gameOver();
        }

        for (let i = 1; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) {
                return gameOver();
            }
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
            score += 10;
            scoreElement.textContent = score;
            generateFood();
        } else {
            snake.pop();
        }
    }

    function draw() {
        ctx.fillStyle = COLORS.BACKGROUND;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.strokeStyle = COLORS.GRID;
        for (let i = 0; i < TILE_COUNT; i++) {
            ctx.beginPath();
            ctx.moveTo(i * GRID_SIZE, 0);
            ctx.lineTo(i * GRID_SIZE, CANVAS_HEIGHT);
            ctx.moveTo(0, i * GRID_SIZE);
            ctx.lineTo(CANVAS_WIDTH, i * GRID_SIZE);
            ctx.stroke();
        }

        drawRect(food.x, food.y, COLORS.FOOD, COLORS.FOOD_GLOW);
        
        snake.forEach((part, index) => {
            const color = index === 0 ? COLORS.SNAKE_HEAD : COLORS.SNAKE_BODY;
            drawRect(part.x, part.y, color, COLORS.SNAKE_GLOW);
            // Augen nur für den Kopf zeichnen
            if (index === 0) {
                drawEyes(part);
            }
        });
    }
    
    function drawRect(gridX, gridY, color, glowColor) {
        ctx.fillStyle = color;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 10;
        ctx.fillRect(gridX * GRID_SIZE, gridY * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        ctx.shadowBlur = 0;
    }

    function drawEyes(head) {
        const eyeSize = GRID_SIZE / 5;
        ctx.fillStyle = COLORS.SNAKE_EYE;
        
        if (direction.x === 1) { // Rechts
            ctx.fillRect((head.x + 0.6) * GRID_SIZE, (head.y + 0.2) * GRID_SIZE, eyeSize, eyeSize);
            ctx.fillRect((head.x + 0.6) * GRID_SIZE, (head.y + 0.6) * GRID_SIZE, eyeSize, eyeSize);
        } else if (direction.x === -1) { // Links
            ctx.fillRect((head.x + 0.2) * GRID_SIZE, (head.y + 0.2) * GRID_SIZE, eyeSize, eyeSize);
            ctx.fillRect((head.x + 0.2) * GRID_SIZE, (head.y + 0.6) * GRID_SIZE, eyeSize, eyeSize);
        } else if (direction.y === 1) { // Unten
            ctx.fillRect((head.x + 0.2) * GRID_SIZE, (head.y + 0.6) * GRID_SIZE, eyeSize, eyeSize);
            ctx.fillRect((head.x + 0.6) * GRID_SIZE, (head.y + 0.6) * GRID_SIZE, eyeSize, eyeSize);
        } else if (direction.y === -1) { // Oben
            ctx.fillRect((head.x + 0.2) * GRID_SIZE, (head.y + 0.2) * GRID_SIZE, eyeSize, eyeSize);
            ctx.fillRect((head.x + 0.6) * GRID_SIZE, (head.y + 0.2) * GRID_SIZE, eyeSize, eyeSize);
        }
    }

    function generateFood() {
        food.x = Math.floor(Math.random() * TILE_COUNT);
        food.y = Math.floor(Math.random() * TILE_COUNT);
        snake.forEach(part => {
            if (part.x === food.x && part.y === food.y) generateFood();
        });
    }

    function gameOver() {
        isGameOver = true;
        clearInterval(gameLoopId);
        startBtn.disabled = false;
        difficultySelect.disabled = false;
        finalScoreElement.textContent = score;
        if (score > 0) {
            modal.style.display = 'flex';
        }
    }

    function changeDirection(event) {
        if (changingDirection) return;
        changingDirection = true;

        const keyPressed = event.key;
        const goingUp = direction.y === -1;
        const goingDown = direction.y === 1;
        const goingLeft = direction.x === -1;
        const goingRight = direction.x === 1;

        if (['ArrowUp', 'w'].includes(keyPressed) && !goingDown) direction = { x: 0, y: -1 };
        if (['ArrowDown', 's'].includes(keyPressed) && !goingUp) direction = { x: 0, y: 1 };
        if (['ArrowLeft', 'a'].includes(keyPressed) && !goingRight) direction = { x: -1, y: 0 };
        if (['ArrowRight', 'd'].includes(keyPressed) && !goingLeft) direction = { x: 1, y: 0 };
    }

    // --- Event Listener ---
    document.addEventListener('keydown', changeDirection);
    startBtn.addEventListener('click', startGame);

    // KORRIGIERTE MODAL-LOGIK
    restartGameBtn.addEventListener('click', startGame);
    closeModalBtn.addEventListener('click', () => {
        modal.style.display = 'none';
        init(); // Setzt das Spiel zurück, ohne es zu starten
    });

    saveScoreBtn.addEventListener('click', () => {
        const playerName = playerNameInput.value.trim() || 'ANONYM';
        fetch("{% url 'games:save_score' %}", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({ player_name: playerName, game: 'Snake', score: score })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                modal.style.display = 'none';
                window.location.href = "{% url 'games:highscores' %}";
            }
        });
    });

    init(); // Initialisiert das Spiel beim Laden der Seite
});
</script>
{% endblock %}