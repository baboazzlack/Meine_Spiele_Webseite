{% extends 'base.html' %}
{% load static %}

{% block title %}Neon Pac-Man - GFN Retro Hub{% endblock %}

{% block content %}
<main class="main-content">
    <div class="si-game-wrapper">
        <div class="si-ui-panel">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 3</div>
        </div>
        <canvas id="game-canvas"></canvas>
        <div id="start-overlay" class="si-game-overlay">
            <h2>NEON PAC-MAN</h2>
            <div class="si-difficulty-select">
                <button data-difficulty="easy">LEICHT</button>
                <button data-difficulty="medium">MITTEL</button>
                <button data-difficulty="hard">SCHWER</button>
            </div>
        </div>
        <div id="game-over-overlay" class="si-game-overlay hidden">
            <h2>GAME OVER</h2>
            <p id="final-score">DEIN SCORE: 0</p>
            <form id="highscore-form">
                <input type="text" id="player-name" placeholder="DEIN NAME" maxlength="10" required>
                <button type="submit">SPEICHERN</button>
            </form>
            <button id="restart-btn">NEUSTART</button>
        </div>
    </div>
    <div id="mobile-controls" class="pacman-controls">
        <div class="d-pad">
            <div id="btn-left" class="mobile-btn">&lt;</div>
            <div id="btn-right" class="mobile-btn">&gt;</div>
            <div id="btn-up" class="mobile-btn">^</div>
            <div id="btn-down" class="mobile-btn">v</div>
        </div>
        <div class="action-buttons"><div id="btn-fire" class="mobile-btn"></div></div>
    </div>
</main>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- ELEMENTE & UI ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const startOverlay = document.getElementById('start-overlay');
    const gameOverOverlay = document.getElementById('game-over-overlay');
    const finalScoreEl = document.getElementById('final-score');
    const restartBtn = document.getElementById('restart-btn');
    const difficultyButtons = document.querySelectorAll('.si-difficulty-select button');
    const highscoreForm = document.getElementById('highscore-form');
    const playerNameInput = document.getElementById('player-name');
    const mobileControls = document.getElementById('mobile-controls');

    const TILE_SIZE = 24;
    const map = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
        [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
        [0,0,0,1,0,1,2,2,2,2,2,2,2,1,0,1,0,0,0],
        [1,1,1,1,0,1,2,1,1,4,1,1,2,1,0,1,1,1,1],
        [2,2,2,2,0,2,2,1,4,4,4,1,2,2,0,2,2,2,2],
        [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
        [0,0,0,1,0,1,2,2,2,2,2,2,2,1,0,1,0,0,0],
        [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    canvas.width = map[0].length * TILE_SIZE;
    canvas.height = map.length * TILE_SIZE;
    
    let player, ghosts, pellets, score, lives, game, difficulty, keys, animationId, frameCounter, frightenedTimerId;
    const difficulties = { easy: { tickSpeed: 7, ghostSpeed: 9, frightTime: 8000 }, medium: { tickSpeed: 6, ghostSpeed: 7, frightTime: 6000 }, hard: { tickSpeed: 5, ghostSpeed: 5, frightTime: 4000 } };

    class Entity {
        constructor(col, row) { this.col = col; this.row = row; this.vel = { x: 0, y: 0 }; }
        isWall(col, row) { const tile = map[row]?.[col]; return tile === 1 || tile === 4; }
    }
    class Player extends Entity {
        constructor(col, row) { super(col, row); this.radius = TILE_SIZE / 2.5; this.mouthOpen = 0; this.nextVel = { x: 0, y: 0 }; this.rotation = 0; }
        draw() { const x = this.col * TILE_SIZE + TILE_SIZE/2; const y = this.row * TILE_SIZE + TILE_SIZE/2; this.mouthOpen = Math.abs(Math.sin(frameCounter * 0.4)); ctx.save(); ctx.translate(x, y); ctx.rotate(this.rotation); ctx.translate(-x, -y); ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(x, y, this.radius, 0.25 * Math.PI + this.mouthOpen, 1.75 * Math.PI - this.mouthOpen); ctx.lineTo(x, y); ctx.closePath(); ctx.fill(); ctx.restore(); }
        update() { if (!this.isWall(this.col + this.nextVel.x, this.row + this.nextVel.y)) { this.vel = { ...this.nextVel }; } if (!this.isWall(this.col + this.vel.x, this.row + this.vel.y)) { this.col += this.vel.x; this.row += this.vel.y; if (this.vel.x > 0) this.rotation = 0; else if (this.vel.x < 0) this.rotation = Math.PI; else if (this.vel.y > 0) this.rotation = Math.PI / 2; else if (this.vel.y < 0) this.rotation = -Math.PI / 2; } if (this.col <= -1) this.col = map[0].length - 1; else if (this.col >= map[0].length) this.col = 0; }
    }
    class Ghost extends Entity {
        constructor(col, row, color) { super(col, row); this.radius = TILE_SIZE / 2.5; this.color = color; this.state = 'normal'; this.target = { col: 0, row: 0 }; this.spawnCol = col; this.spawnRow = row; }
        draw() { const x = this.col * TILE_SIZE + TILE_SIZE/2; const y = this.row * TILE_SIZE + TILE_SIZE/2; ctx.fillStyle = this.state === 'frightened' ? '#6495ED' : this.color; ctx.beginPath(); ctx.arc(x, y, this.radius, Math.PI, 0); ctx.lineTo(x + this.radius, y + this.radius); ctx.lineTo(x - this.radius, y + this.radius); ctx.closePath(); ctx.fill(); }
        update() { const possibleMoves = []; if (!this.isWall(this.col, this.row - 1)) possibleMoves.push({x:0, y:-1}); if (!this.isWall(this.col, this.row + 1)) possibleMoves.push({x:0, y:1}); if (!this.isWall(this.col - 1, this.row)) possibleMoves.push({x:-1, y:0}); if (!this.isWall(this.col + 1, this.row)) possibleMoves.push({x:1, y:0}); const back = { x: -this.vel.x, y: -this.vel.y }; let options = possibleMoves; if (options.length > 1) { options = options.filter(opt => !(opt.x === back.x && opt.y === back.y)); } if(options.length > 0) { let bestOption = options[0]; if (options.length > 1) { let minDistance = Infinity; let maxDistance = -Infinity; options.forEach(opt => { let targetCol = this.target.col; let targetRow = this.target.row; if (this.state === 'frightened') { targetCol = this.spawnCol; targetRow = this.spawnRow; } const dist = Math.hypot((this.col + opt.x) - targetCol, (this.row + opt.y) - targetRow); if (this.state === 'frightened') { if (dist > maxDistance) { maxDistance = dist; bestOption = opt; } } else { if (dist < minDistance) { minDistance = dist; bestOption = opt; } } }); } this.vel = bestOption; } if (!this.isWall(this.col + this.vel.x, this.row + this.vel.y)) { this.col += this.vel.x; this.row += this.vel.y; } }
    }
    class Pellet { constructor(col, row) { this.col = col; this.row = row; } draw() { ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(this.col * TILE_SIZE + TILE_SIZE/2, this.row * TILE_SIZE + TILE_SIZE/2, 3, 0, Math.PI * 2); ctx.fill(); } }
    class PowerPellet { constructor(col, row) { this.col = col; this.row = row; } draw() { ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(this.col * TILE_SIZE + TILE_SIZE/2, this.row * TILE_SIZE + TILE_SIZE/2, 8 * (Math.sin(frameCounter * 0.1) * 0.2 + 0.8), 0, Math.PI * 2); ctx.fill(); } }

    function drawMap() { map.forEach((row, r) => { row.forEach((tile, c) => { if (tile === 1) { ctx.fillStyle = '#0000FF'; ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE); } }); }); }

    function init() {
        player = new Player(9, 13);
        ghosts = [ new Ghost(1, 1, '#FF0000'), new Ghost(17, 1, '#FFB8FF'), new Ghost(1, 15, '#00FFFF'), new Ghost(17, 15, '#FFB852') ];
        pellets = []; score = 0; lives = 3; frameCounter = 0;
        keys = { up: false, down: false, left: false, right: false };
        game = { active: true, over: false };
        scoreEl.innerText = `SCORE: ${score}`; livesEl.innerText = `LIVES: ${lives}`;
        map.forEach((row, r) => { row.forEach((tile, c) => { if (tile === 0) { pellets.push(new Pellet(c, r)); } else if (tile === 3) { pellets.push(new PowerPellet(c, r)); } }); });
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMap();
        pellets.forEach(p => p.draw());
        player.draw();
        ghosts.forEach(g => g.draw());
        
        if (frameCounter % difficulty.tickSpeed === 0) { player.update(); for (let i = pellets.length - 1; i >= 0; i--) { const p = pellets[i]; if (p.col === player.col && p.row === player.row) { if (p instanceof PowerPellet) { score += 50; if (frightenedTimerId) clearTimeout(frightenedTimerId); ghosts.forEach(g => g.state = 'frightened'); frightenedTimerId = setTimeout(() => ghosts.forEach(g => g.state = 'normal'), difficulty.frightTime); } else score += 10; scoreEl.innerText = `SCORE: ${score}`; pellets.splice(i, 1); } } if (pellets.length === 0) endGame(true); }
        if (frameCounter % difficulty.ghostSpeed === 0) { ghosts.forEach(g => { g.target = {col: player.col, row: player.row}; g.update(); if (g.col === player.col && g.row === player.row) { if(g.state === 'frightened') { score += 200; g.col = g.spawnCol; g.row = g.spawnRow; } else { lives--; livesEl.innerText = `LIVES: ${lives}`; if (lives <= 0) endGame(); else { player = new Player(9, 13); } } } }); }
        
        frameCounter++;
    }

    function startGame(diff) { difficulty = difficulties[diff]; init(); startOverlay.classList.add('hidden'); game.active = true; animate(); }
    function endGame(win = false) { if (game.over) return; game.active = false; game.over = true; cancelAnimationFrame(animationId); if (win) score += 1000; finalScoreEl.innerText = `DEIN SCORE: ${score}`; gameOverOverlay.classList.remove('hidden'); }
    
    difficultyButtons.forEach(b => b.addEventListener('click', () => startGame(b.dataset.difficulty)));
    restartBtn.addEventListener('click', () => { gameOverOverlay.classList.add('hidden'); startOverlay.classList.remove('hidden'); });
    highscoreForm.addEventListener('submit', async (e) => { e.preventDefault(); const name = playerNameInput.value.trim().toUpperCase(); if (!name) return; try { await fetch("{% url 'games:save_score' %}", { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' }, body: JSON.stringify({ player_name: name, game: 'Pac-Man', score: score }) }); } catch (err) { console.error(err); } finally { playerNameInput.value = ''; restartBtn.click(); } });
    
    function keyHandler(e) { if (!game.active) return; switch (e.key) { case 'w': case 'ArrowUp': player.nextVel = {x: 0, y: -1}; break; case 's': case 'ArrowDown': player.nextVel = {x: 0, y: 1}; break; case 'a': case 'ArrowLeft': player.nextVel = {x: -1, y: 0}; break; case 'd': case 'ArrowRight': player.nextVel = {x: 1, y: 0}; break; } }
    addEventListener('keydown', keyHandler);

    if ('ontouchstart' in window) {
        mobileControls.classList.add('visible');
        const up = document.getElementById('btn-up'), down = document.getElementById('btn-down'), left = document.getElementById('btn-left'), right = document.getElementById('btn-right');
        up.addEventListener('touchstart', (e) => { e.preventDefault(); player.nextVel = {x: 0, y: -1}; });
        down.addEventListener('touchstart', (e) => { e.preventDefault(); player.nextVel = {x: 0, y: 1}; });
        left.addEventListener('touchstart', (e) => { e.preventDefault(); player.nextVel = {x: -1, y: 0}; });
        right.addEventListener('touchstart', (e) => { e.preventDefault(); player.nextVel = {x: 1, y: 0}; });
    }
});
</script>
{% endblock %}