{% extends 'base.html' %}
{% block title %}Tetris{% endblock %}
{% block content %}
    <h2>Tetris</h2>

    <style>
        #game-container { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }
        #main-game { position: relative; }
        #game-board { border: 3px solid #32c8e6; background-color: #000; }
        #game-info { width: 150px; text-align: left; }
        #next-piece-canvas { border: 2px solid #533483; background-color: #000; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(12, 12, 28, 0.9); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 1.2em; z-index: 100;}
        .difficulty-button { display: inline-block; padding: 15px 25px; margin: 10px; font-size: 1em; color: #FFFFFF; cursor: pointer; border: 2px solid; }
        .easy { background-color: #28a745; } .medium { background-color: #ffc107; color: #1a1a2e;} .hard { background-color: #dc3545; }
    </style>

    <div id="game-container">
        <div id="main-game">
             <canvas id="game-board" width="300" height="600"></canvas>
             <div id="overlay">
                <h3>TETRIS</h3>
                <p>Wähle eine Schwierigkeitsstufe:</p>
                <div>
                    <button class="difficulty-button easy" onclick="startGame('easy')">Leicht</button>
                    <button class="difficulty-button medium" onclick="startGame('medium')">Mittel</button>
                    <button class="difficulty-button hard" onclick="startGame('hard')">Schwer</button>
                </div>
                <p style="font-size: 0.8em; margin-top: 40px;">Steuerung: Pfeile & Leertaste</p>
            </div>
        </div>
        <div id="game-info">
            <h3>Score</h3><p id="score-display">0</p>
            <h3>Level</h3><p id="level-display">1</p>
            <h3>Nächster Stein</h3><canvas id="next-piece-canvas" width="120" height="120"></canvas>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('game-board');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece-canvas');
        const nextContext = nextCanvas.getContext('2d');
        
        const overlay = document.getElementById('overlay');
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        
        // KORREKTUR: Die originalen Tetris-Farben!
        const COLORS = [
            null, 'cyan', 'yellow', 'purple', 'lime', 'red', 'blue', 'orange'
        ];
        
        const SHAPES = [
            [], [[1,1,1,1]], [[2,2],[2,2]], [[0,3,0],[3,3,3]], [[4,4,0],[0,4,4]],
            [[0,5,5],[5,5,0]], [[6,0,0],[6,6,6]], [[0,0,7],[7,7,7]]
        ];

        let board, piece, nextPiece, score, level, linesCleared, dropCounter, dropInterval, lastTime, isGameOver, gameLoopId, currentDifficulty;

        function createPiece() {
            const index = Math.floor(Math.random() * 7) + 1;
            const matrix = SHAPES[index];
            return {
                matrix: matrix,
                colorIndex: index,
                x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2),
                y: 0
            };
        }
        
        function startGame(difficulty) {
            currentDifficulty = difficulty;
            const speedMap = { easy: 1000, medium: 800, hard: 500 };
            dropInterval = speedMap[difficulty];
            
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            piece = createPiece();
            nextPiece = createPiece();
            score = 0; level = 1; linesCleared = 0;
            isGameOver = false;
            lastTime = 0;
            dropCounter = 0;
            overlay.style.display = 'none';

            cancelAnimationFrame(gameLoopId);
            update();
        }

        function rotate(matrix) {
            const result = [];
            for (let y = 0; y < matrix[0].length; y++) {
                result[y] = [];
                for (let x = 0; x < matrix.length; x++) {
                    result[y][x] = matrix[matrix.length - 1 - x][y];
                }
            }
            return result;
        }

        function collide(board, piece) {
            const { matrix, x, y } = piece;
            for (let row = 0; row < matrix.length; row++) {
                for (let col = 0; col < matrix[row].length; col++) {
                    if (matrix[row][col] && ( (board[row + y] && board[row + y][col + x]) !== 0) ) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(board, piece) {
            piece.matrix.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        board[r + piece.y][c + piece.x] = piece.colorIndex;
                    }
                });
            });
        }
        
        // KORREKTUR: Überarbeitete und reparierte Funktion zum Löschen von Reihen
        function clearLines() {
            let clearedCount = 0;
            outer: for (let y = board.length - 1; y >= 0; y--) {
                for (let x = 0; x < board[y].length; x++) {
                    if (board[y][x] === 0) {
                        continue outer; // Wenn eine Zelle leer ist, ist die Reihe nicht voll -> nächste Reihe
                    }
                }
                // Wenn wir hier ankommen, ist die Reihe voll
                const row = board.splice(y, 1)[0].fill(0); // Reihe löschen und mit 0 füllen
                board.unshift(row); // Leere Reihe oben einfügen
                y++; // Index anpassen, da sich das Array verändert hat
                clearedCount++;
            }
            // Score-Berechnung
            if (clearedCount > 0) {
                const points = [0, 100, 300, 500, 800]; // Punkte für 1, 2, 3 oder 4 Reihen
                score += points[clearedCount] * level;
                linesCleared += clearedCount;
                if (linesCleared >= level * 10) {
                    level++;
                    dropInterval = Math.max(100, dropInterval * 0.9); // 10% schneller
                }
            }
        }

        function pieceDrop() {
            piece.y++;
            if (collide(board, piece)) {
                piece.y--;
                merge(board, piece);
                clearLines();
                piece = nextPiece;
                nextPiece = createPiece();
                if (collide(board, piece)) {
                    gameOver();
                }
            }
            dropCounter = 0;
        }

        function drawMatrix(matrix, offset, ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                });
            });
        }
        
        function draw() {
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            drawMatrix(board, {x: 0, y: 0}, context);
            drawMatrix(piece.matrix, {x: piece.x, y: piece.y}, context);

            nextContext.fillStyle = '#000';
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            const nextOffset = { x: (4 - nextPiece.matrix[0].length) / 2, y: (4 - nextPiece.matrix.length) / 2 };
            drawMatrix(nextPiece.matrix, nextOffset, nextContext);
        }

        function update(time = 0) {
            if (isGameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) pieceDrop();
            draw();
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            gameLoopId = requestAnimationFrame(update);
        }
        
        function gameOver() {
            cancelAnimationFrame(gameLoopId);
            isGameOver = true;
            overlay.style.display = 'flex';
            overlay.innerHTML = `
                <h3>Game Over!</h3><p>Dein Score: ${score}</p>
                <form id="highscore-form"><input type="text" id="player-name" placeholder="Dein Name..." required><button type="submit">Highscore speichern</button></form>
                <p style="margin-top:20px; font-size: 0.8em">Neues Spiel:</p>
                <div><button class="difficulty-button easy" onclick="startGame('easy')">Leicht</button><button class="difficulty-button medium" onclick="startGame('medium')">Mittel</button><button class="difficulty-button hard" onclick="startGame('hard')">Schwer</button></div>`;
            document.getElementById('highscore-form').addEventListener('submit', function(event) {
                event.preventDefault();
                fetch("{% url 'games:save_score' %}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
                    body: JSON.stringify({ player_name: document.getElementById('player-name').value, score: score, game: 'Tetris', difficulty: currentDifficulty })
                }).then(() => window.location.href = "{% url 'games:highscores' %}");
            });
        }
        
        document.addEventListener('keydown', e => {
            if (isGameOver) return;
            if (e.key === 'ArrowLeft') { piece.x--; if (collide(board, piece)) piece.x++; }
            else if (e.key === 'ArrowRight') { piece.x++; if (collide(board, piece)) piece.x--; }
            else if (e.key === 'ArrowDown') { pieceDrop(); }
            else if (e.key === 'ArrowUp') {
                const rotated = rotate(piece.matrix); const posX = piece.x; let offset = 1;
                while (collide(board, { ...piece, matrix: rotated })) {
                    piece.x += offset; offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > rotated[0].length + 1) { piece.x = posX; return; }
                }
                piece.matrix = rotated;
            } else if (e.key === ' ') {
                 while (!collide(board, piece)) { piece.y++; }
                 piece.y--; pieceDrop();
            }
        });
    </script>
{% endblock %}