{% extends 'base.html' %}
{% load static %}

{% block title %}Tetris - GFN Retro Hub{% endblock %}

{% block content %}
<main class="game-container-main">
    <div class="game-header">
        <h1 class="game-title-h1">Tetris</h1>
        <p class="game-description">Die Blöcke fallen! Ordne sie in Reihen an, bevor der Stapel die Decke erreicht.</p>
    </div>

    <div class="game-layout-tetris">
        <div class="game-info-panel left">
            <h3>Score</h3>
            <p id="score">0</p>
            <h3>Reihen</h3>
            <p id="lines">0</p>
            <h3>Level</h3>
            <p id="level">1</p>
        </div>

        <canvas id="tetrisCanvas" width="300" height="600"></canvas>

        <div class="game-info-panel right">
            <h3>Nächster</h3>
            <canvas id="nextCanvas" width="120" height="120"></canvas>
            <div class="game-controls-tetris">
                 <label for="difficulty">Schwierigkeit:</label>
                 <select id="difficulty">
                     <option value="easy">Leicht</option>
                     <option value="medium" selected>Mittel</option>
                     <option value="hard">Schwer</option>
                 </select>
            </div>
            <button id="startGameBtn">Spiel Starten</button>
        </div>
    </div>

    <div id="gameOverModal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>Game Over</h2>
            <p>Dein Score: <span id="finalScore">0</span></p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="15">
            <div class="modal-actions">
                <button id="saveScoreBtn">Speichern</button>
                <button id="restartGameBtn">Neues Spiel</button>
                <button id="closeModalBtn">Schließen</button>
            </div>
        </div>
    </div>
</main>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elemente ---
    const canvas = document.getElementById('tetrisCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const linesEl = document.getElementById('lines');
    const levelEl = document.getElementById('level');
    const startBtn = document.getElementById('startGameBtn');
    const difficultySelect = document.getElementById('difficulty');
    const modal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const playerNameInput = document.getElementById('playerNameInput');
    const saveScoreBtn = document.getElementById('saveScoreBtn');
    const restartGameBtn = document.getElementById('restartGameBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');

    // --- Spiel-Konstanten ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30;
    const COLORS = {
        I: '#00ffff', T: '#800080', O: '#ffff00', L: '#ff7f00',
        J: '#0000ff', S: '#00ff00', Z: '#ff0000', GHOST: 'rgba(255, 255, 255, 0.2)'
    };
    const SHAPES = {
        I: [[1,1,1,1]],
        T: [[0,1,0], [1,1,1]],
        O: [[1,1], [1,1]],
        L: [[0,0,1], [1,1,1]],
        J: [[1,0,0], [1,1,1]],
        S: [[0,1,1], [1,1,0]],
        Z: [[1,1,0], [0,1,1]]
    };
    const PIECES = 'ITOLJSZ';

    // --- Spiel-Variablen ---
    let board, currentPiece, nextPiece, score, lines, level, dropCounter, dropInterval, gameLoopId, gameActive;

    function init() {
        gameActive = true;
        board = createBoard();
        score = 0;
        lines = 0;
        level = 1;
        updateInfo();
        
        nextPiece = createPiece();
        spawnNewPiece();

        dropCounter = 0;
        setDropInterval();

        modal.style.display = 'none';
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
    }
    
    function startGame() {
        init();
        startBtn.disabled = true;
        difficultySelect.disabled = true;
        gameLoop();
    }

    function createBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }

    function createPiece() {
        const type = PIECES[Math.floor(Math.random() * PIECES.length)];
        return {
            type,
            shape: SHAPES[type],
            color: COLORS[type],
            x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
            y: 0
        };
    }
    
    function spawnNewPiece() {
        currentPiece = nextPiece;
        nextPiece = createPiece();
        if (collides(currentPiece, board)) {
            gameOver();
        }
        drawNextPiece();
    }

    function gameLoop(time = 0) {
        if (!gameActive) return;
        
        dropCounter += 1;
        if (dropCounter > dropInterval) {
            pieceDrop();
        }
        
        draw();
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function pieceDrop() {
        currentPiece.y++;
        if (collides(currentPiece, board)) {
            currentPiece.y--;
            mergePiece();
            clearLines();
            spawnNewPiece();
        }
        dropCounter = 0;
    }

    function hardDrop() {
        while (!collides(currentPiece, board)) {
            currentPiece.y++;
        }
        currentPiece.y--;
        mergePiece();
        clearLines();
        spawnNewPiece();
    }

    function mergePiece() {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
                }
            });
        });
    }

    function clearLines() {
        let linesCleared = 0;
        outer: for (let y = ROWS - 1; y >= 0; y--) {
            for (let x = 0; x < COLS; x++) {
                if (board[y][x] === 0) continue outer;
            }
            const row = board.splice(y, 1)[0].fill(0);
            board.unshift(row);
            linesCleared++;
            y++;
        }
        if (linesCleared > 0) {
            lines += linesCleared;
            const points = [0, 100, 300, 500, 800];
            score += points[linesCleared] * level;
            level = Math.floor(lines / 10) + 1;
            setDropInterval();
            updateInfo();
        }
    }
    
    function collides(piece, board) {
        for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x] && (
                    board[piece.y + y] &&
                    board[piece.y + y][piece.x + x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function rotate() {
        const shape = currentPiece.shape;
        const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse());
        const originalX = currentPiece.x;
        let offset = 1;
        
        currentPiece.shape = newShape;
        while(collides(currentPiece, board)){
            currentPiece.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if(offset > currentPiece.shape[0].length) {
                currentPiece.shape = shape;
                currentPiece.x = originalX;
                return;
            }
        }
    }

    function setDropInterval() {
        const difficulty = difficultySelect.value;
        const baseSpeed = { easy: 50, medium: 40, hard: 30 };
        dropInterval = baseSpeed[difficulty] - (level * 2);
        if (dropInterval < 5) dropInterval = 5;
    }

    function updateInfo() {
        scoreEl.textContent = score;
        linesEl.textContent = lines;
        levelEl.textContent = level;
    }

    function gameOver() {
        gameActive = false;
        cancelAnimationFrame(gameLoopId);
        finalScoreEl.textContent = score;
        startBtn.disabled = false;
        difficultySelect.disabled = false;
        if(score > 0) {
            modal.style.display = 'flex';
        }
    }

    // --- Draw Functions ---
    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawBoard(board, ctx);
        drawPiece(currentPiece, ctx);
        drawGhostPiece();
    }

    function drawBoard(board, context) {
        board.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    drawBlock(x, y, value, context);
                }
            });
        });
    }

    function drawPiece(piece, context, offset = {x: 0, y: 0}) {
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    // *** KORRIGIERTE LOGIK HIER ***
                    // Für die Vorschau wird nur der Offset verwendet, für das Hauptspiel die Position des Steins.
                    const drawX = (offset.x > 0) ? (offset.x + x) : (piece.x + x);
                    const drawY = (offset.y > 0) ? (offset.y + y) : (piece.y + y);
                    drawBlock(drawX, drawY, piece.color, context);
                }
            });
        });
    }
    
    function drawGhostPiece() {
        const ghost = { ...currentPiece, shape: currentPiece.shape.map(r => [...r]) }; // Tiefe Kopie
        ghost.color = COLORS.GHOST;
        while (!collides(ghost, board)) {
            ghost.y++;
        }
        ghost.y--;
        drawPiece(ghost, ctx);
    }

    function drawNextPiece() {
        nextCtx.fillStyle = '#000';
        nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
        const offset = {
            x: (4 - nextPiece.shape[0].length) / 2,
            y: (4 - nextPiece.shape.length) / 2
        };
        drawPiece(nextPiece, nextCtx, offset);
    }
    
    function drawBlock(x, y, color, context) {
        context.fillStyle = color;
        context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        context.strokeStyle = '#000';
        context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        context.shadowColor = color;
        context.shadowBlur = 10;
        context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
        context.shadowBlur = 0;
    }

    // --- Event Listeners ---
    document.addEventListener('keydown', e => {
        if (!gameActive) return;
        if (['ArrowLeft', 'a'].includes(e.key)) { currentPiece.x--; if (collides(currentPiece, board)) currentPiece.x++; }
        if (['ArrowRight', 'd'].includes(e.key)) { currentPiece.x++; if (collides(currentPiece, board)) currentPiece.x--; }
        if (['ArrowDown', 's'].includes(e.key)) { pieceDrop(); }
        if (['ArrowUp', 'w'].includes(e.key)) { rotate(); }
        if (e.key === ' ') { e.preventDefault(); hardDrop(); }
    });

    startBtn.addEventListener('click', startGame);
    restartGameBtn.addEventListener('click', () => { modal.style.display = 'none'; startGame(); });
    closeModalBtn.addEventListener('click', () => { modal.style.display = 'none'; });
    
    saveScoreBtn.addEventListener('click', () => {
        const playerName = playerNameInput.value.trim() || 'ANONYM';
        if (score > 0) {
             fetch("{% url 'games:save_score' %}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
                body: JSON.stringify({ player_name: playerName, game: 'Tetris', score: score })
            })
            .then(res => res.json())
            .then(data => { if(data.status === 'success') window.location.href = "{% url 'games:highscores' %}"; });
        }
    });
    
    // Initialen Zustand zeichnen
    drawBoard(createBoard(), ctx);
});
</script>
{% endblock %}